{
  "version": 3,
  "sources": ["../src/image-loader.js", "../src/worker-loader.js", "../src/texture-format.js", "../src/texture-loader-base.js", "../src/webgl-texture-loader.js"],
  "sourcesContent": ["/**\n * @file Loader which handles any image types supported directly by the browser.\n * @module ImageLoader\n */\n\nconst MIME_TYPE_FORMATS = {\n  'image/jpeg': 'rgb8unorm',\n  'image/png': 'rgba8unorm',\n  'image/apng': 'rgba8unorm',\n  'image/gif': 'rgba8unorm',\n  'image/bmp': 'rgb8unorm',\n  'image/webp': 'rgba8unorm',\n  'image/x-icon': 'rgba8unorm',\n  'image/svg+xml': 'rgba8unorm',\n};\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\n/**\n * Loader which handles any image types supported directly by the browser.\n */\nexport class ImageLoader {\n  /**\n   * Creates a ImageTextureLoader instance.\n   * Should only be called by the WebTextureTool constructor.\n   */\n  constructor() {\n  }\n\n  /**\n   * Which MIME types this loader supports.\n   *\n   * @returns {Array<string>} - An array of the MIME types this loader supports.\n   */\n  static supportedMIMETypes() {\n    return Object.keys(MIME_TYPE_FORMATS);\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromUrl(client, url, options) {\n    let format = MIME_TYPE_FORMATS[options.mimeType];\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const response = await fetch(url);\n      const imageBitmap = await createImageBitmap(await response.blob());\n      return client.fromImageBitmap(imageBitmap, format, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.textureFromImageElement(imageElement, format, options));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBlob(client, blob, options) {\n    let format = MIME_TYPE_FORMATS[blob.type];\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const imageBitmap = await createImageBitmap(blob);\n      return client.fromImageBitmap(imageBitmap, format, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.fromImageElement(imageElement, format, options));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        const url = window.URL.createObjectURL(blob);\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBuffer(client, buffer, options) {\n    const blob = new Blob(buffer, {type: options.mimeType});\n    return this.fromBlob(client, blob, options);\n  }\n\n  /**\n   * Destroy this loader.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    // Nothing to clean up here.\n  }\n}\n", "/**\n * Generic loader which handles texture loading in a worker in order to prevent blocking the main thread.\n *\n * @file Loader that operates a worker script\n * @module WorkerLoader\n */\n\nconst WORKER_DIR = import.meta.url.replace(/[^\\/]*$/, '');\nconst MAX_WORKER_POOL_SIZE = 4;\n\n/**\n * Tracks required data for fulfilling a texture request once it has been transcoded.\n */\nclass PendingTextureRequest {\n  /**\n   * Creates a PendingTextureRequest instance.\n   *\n   * @param {object} client - The WebTextureClient that will upload the transcoded data.\n   * @param {*} options - Options passed during the texture request.\n   * @param {*} resolve - Success callback.\n   * @param {*} reject - Failure callback.\n   */\n  constructor(client, options, resolve, reject) {\n    this.client = client;\n    this.options = options;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\n\nconst pendingTextures = {};\nlet nextPendingTextureId = 1;\n\n/**\n * Called when the worker either finished transcoding a file or encounters an error.\n *\n * @param {object} msg - Message contents from the worker\n * @returns {void}\n */\nfunction onWorkerMessage(msg) {\n  // Find the pending texture associated with the data we just received\n  // from the worker.\n  const pendingTexture = pendingTextures[msg.data.id];\n  if (!pendingTexture) {\n    if (msg.data.error) {\n      console.error(`Texture load failed: ${msg.data.error}`);\n    }\n    console.error(`Invalid pending texture ID: ${msg.data.id}`);\n    return;\n  }\n\n  // Remove the pending texture from the waiting list.\n  delete pendingTextures[msg.data.id];\n\n  // If the worker indicated an error has occured handle it now.\n  if (msg.data.error) {\n    console.error(`Texture load failed: ${msg.data.error}`);\n    pendingTexture.reject(`${msg.data.error}`);\n    return;\n  }\n\n  // Upload the image data returned by the worker.\n  const result = pendingTexture.client.fromTextureData(msg.data, pendingTexture.options);\n  pendingTexture.resolve(result);\n}\n\n/**\n * Loader which handles Basis Universal files.\n */\nexport class WorkerLoader {\n  /**\n   * Creates a WorkerLoader instance.\n   *\n   * @param {string} relativeWorkerPath - Path to the worker script to load, relative to this file.\n   */\n  constructor(relativeWorkerPath) {\n    // Load the worker script.\n    this.workerPath = `${WORKER_DIR}${relativeWorkerPath}`;\n    this.workerPool = [];\n    this.nextWorker = 0;\n    this.outstandingRequests = 0;\n\n    this.addWorker();\n  }\n\n  addWorker() {\n    const worker = new Worker(this.workerPath);\n    worker.onmessage = (msg) => {\n      onWorkerMessage(msg);\n      this.outstandingRequests--;\n    };\n\n    this.workerPool.push(worker);\n    return worker;\n  }\n\n  selectWorker() {\n    this.outstandingRequests++;\n    if (this.outstandingRequests >= this.workerPool.length && this.workerPool.length < MAX_WORKER_POOL_SIZE) {\n      return this.addWorker();\n    }\n    return this.workerPool[this.nextWorker++ % this.workerPool.length];\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromUrl(client, url, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.selectWorker().postMessage({\n      id: pendingTextureId,\n      url: url,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBlob(client, blob, options) {\n    const buffer = await blob.arrayBuffer();\n    return this.fromBuffer(client, buffer, options);\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBuffer(client, buffer, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.selectWorker().postMessage({\n      id: pendingTextureId,\n      buffer: buffer,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Destroy this loader.\n   * Terminates the worker and rejects any outstanding textures. The loader is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this.worker) {\n      this.worker.terminate();\n\n      const destroyedError = new Error('Texture loader was destroyed.');\n      for (const pendingTexture of pendingTextures) {\n        pendingTexture.reject(destroyedError);\n      }\n    }\n  }\n}\n", "// For access to WebGL enums without a context.\nconst GL = WebGLRenderingContext;\n\n/**\n * Texture Format\n *\n * @typedef {string} WebTextureFormat\n */\n\n// Additional format data used by Web Texture Tool, based off WebGPU formats.\n// WebGL equivalents given where possible.\nexport const WebTextureFormat = {\n  // Uncompressed formats\n  'rgb8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8051}, // RGB8\n  },\n  'rgba8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8058}, // RGBA8\n  },\n  'rgb8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C43}, // SRGB8_ALPHA8\n  },\n  'rgba8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C43}, // SRGB8_ALPHA8\n  },\n  'rgb565unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_SHORT_5_6_5, sizedFormat: GL.RGB565},\n  },\n  'rgba4unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_4_4_4_4, sizedFormat: GL.RGBA4},\n  },\n  'rgba5551unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_5_5_5_1, sizedFormat: GL.RGB5_A1},\n  },\n\n  'bgra8unorm': {canGenerateMipmaps: true}, // No WebGL equivalent\n  'bgra8unorm-srgb': {canGenerateMipmaps: true}, // No WebGL equivalent\n\n  // Compressed formats\n  // WebGL enums from http://www.khronos.org/registry/webgl/extensions/\n  'bc1-rgb-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F0}, // COMPRESSED_RGB_S3TC_DXT1_EXT\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'bc2-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F2}, // COMPRESSED_RGBA_S3TC_DXT3_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc3-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x83F3}, // COMPRESSED_RGBA_S3TC_DXT5_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc7-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x8E8C}, // COMPRESSED_RGBA_BPTC_UNORM_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'etc1-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8D64}, // COMPRESSED_RGB_ETC1_WEBGL\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'etc2-rgba8unorm': {\n    gl: {texStorage: true, sizedFormat: 0x9278}, // COMPRESSED_RGBA8_ETC2_EAC\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'astc-4x4-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x93B0}, // COMPRESSED_RGBA_ASTC_4x4_KHR\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C00}, // COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C02}, // COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n};\n", "/**\n * This library offers a unified way of loading textures for both WebGL and WebGPU from various file formats, and in all\n * cases attempts to handle the loading as efficently as possible. Every effort made to prevent texture loading from\n * blocking the main thread, since that can often be one of the primary causes of jank during page startup or while\n * streaming in new assets.\n *\n * @file Library for loading various image sources as textures for WebGL or WebGPU\n * @module TextureLoaderBase\n */\n\nimport {ImageLoader} from './image-loader.js';\nimport {WorkerLoader} from './worker-loader.js';\nimport {WebTextureFormat} from './texture-format.js';\n\n/**\n * Texture result from calling one of the WebTextureTool methods\n *\n * @property {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n * @property {number} width of mip level 0 in pixels.\n * @property {number} height of mip level 0 in pixels.\n * @property {number} depth of mip level 0 in pixels.\n * @property {number} mipLevels - Number of mip levels the texture contains.\n * @property {WebTextureFormat} format - Format of the texture.\n */\nexport class WebTextureResult {\n  /**\n   * Create an instance of a WebTextureResult.\n   *\n   * @param {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n   * @param {number} width of mip level 0 in pixels.\n   * @param {number} height of mip level 0 in pixels.\n   * @param {number} depth of mip level 0 in pixels.\n   * @param {number} mipLevels - Number of mip levels the texture contains.\n   * @param {WebTextureFormat} format - Format of the texture.\n   */\n  constructor(texture, description = {}) {\n    this.texture = texture;\n    this.width = description.width || 1;\n    this.height = description.height || 1;\n    this.depth = description.depth || 1;\n    this.mipLevels = description.mipLevels || 1;\n    this.format = description.format || 'rgba8unorm';\n    this.type = description.type || '2d';\n  }\n\n  get glFormat() {\n    const texProperties = WebTextureFormat[this.format];\n    return texProperties.gl.format  || null;\n  }\n\n  get glSizedFormat() {\n    const texProperties = WebTextureFormat[this.format];\n    return texProperties.gl.sizedFormat;\n  }\n\n  get glTarget() {\n    switch (this.type) {\n      case 'cube':\n        return GL.TEXTURE_CUBE_MAP;\n      case '2d':\n      default:\n        return GL.TEXTURE_2D;\n    }\n  }\n}\n\nexport class WebTextureData {\n  constructor(format, width, height, imageData = null, imageDataOptions = {}) {\n    this.format = format;\n    this.width = Math.max(1, width);\n    this.height = Math.max(1, height);\n    this.levels = [];\n\n    // Optionally, data for the first image's first mip level can be passed to the constructor to handle simple cases.\n    if (imageData) {\n      this.getLevel(0).setSlice(0, imageData, imageDataOptions);\n    }\n  }\n\n  getLevel(index, options = {}) {\n    let level = this.levels[index];\n    if (!level) {\n      level = new WebTextureLevelData(this, index, options);\n      this.levels[index] = level;\n    }\n    return level;\n  }\n}\n\nclass WebTextureLevelData {\n  constructor(textureData, levelIndex, options) {\n    this.textureData = textureData;\n    this.levelIndex = levelIndex;\n    this.width = Math.max(1, options.width || this.textureData.width >> levelIndex);\n    this.height = Math.max(1, options.height || this.textureData.height >> levelIndex);\n    this.slices = [];\n  }\n\n  setSlice(index, bufferOrTypedArray, options = {}) {\n    if (this.slices[index] != undefined) {\n      throw new Error('Cannot define an image slice twice.');\n    }\n\n    let byteOffset = options.byteOffset || 0;\n    let byteLength = options.byteLength || 0;\n\n    let buffer;\n    if (bufferOrTypedArray instanceof ArrayBuffer) {\n      buffer = bufferOrTypedArray;\n      if (!byteLength) {\n        byteLength = buffer.byteLength - byteOffset;\n      }\n    } else {\n      buffer = bufferOrTypedArray.buffer;\n      if (!byteLength) {\n        byteLength = bufferOrTypedArray.byteLength - byteOffset;\n      }\n      byteOffset += bufferOrTypedArray.byteOffset;\n    }\n\n    this.slices[index] = {\n      buffer,\n      byteOffset,\n      byteLength,\n    };\n  }\n}\n\n/**\n * Associates a set of extensions with a specifc loader.\n */\nclass ExtensionHandler {\n  /**\n   * Creates an ExtensionHandler.\n   *\n   * @param {Array<string>} extensions - List of extensions that this loader can handle.\n   * @param {Function} callback - Callback which returns an instance of the loader.\n   */\n  constructor(mimeTypes, callback) {\n    this.mimeTypes = mimeTypes;\n    this.callback = callback;\n    this.loader = null;\n  }\n\n  /**\n   * Gets the loader associated with this extension set. Creates an instance by calling the callback if one hasn't been\n   * instantiated previously.\n   *\n   * @returns {object} Texture Loader instance.\n   */\n  getLoader() {\n    if (!this.loader) {\n      this.loader = this.callback();\n    }\n    return this.loader;\n  }\n}\n\nconst EXTENSION_MIME_TYPES = {\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  apng: 'image/apng',\n  gif: 'image/gif',\n  bmp: 'image/bmp',\n  webp: 'image/webp',\n  ico: 'image/x-icon',\n  cur: 'image/x-icon',\n  svg: 'image/svg+xml',\n  basis: 'image/basis',\n  ktx: 'image/ktx',\n  ktx2: 'image/ktx2',\n  dds: 'image/vnd.ms-dds',\n};\n\nconst EXTENSION_HANDLERS = [\n  new ExtensionHandler(ImageLoader.supportedMIMETypes(), () => new ImageLoader()),\n  new ExtensionHandler(['image/basis'], () => new WorkerLoader('workers/basis/basis-worker.js')),\n  new ExtensionHandler(['image/ktx', 'image/ktx2'], () => new WorkerLoader('workers/ktx/ktx-worker.js')),\n  new ExtensionHandler(['image/vnd.ms-dds'], () => new WorkerLoader('workers/dds-worker.js')),\n];\n\nconst CLIENT = Symbol('wtt/WebTextureClient');\nconst LOADERS = Symbol('wtt/WebTextureLoaders');\n\nconst TMP_ANCHOR = document.createElement('a');\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\nconst DEFAULT_URL_OPTIONS = {\n  mimeType: null,\n  mipmaps: true,\n  colorSpace: 'default',\n};\n\nfunction getMimeTypeLoader(wtt, mimeType) {\n  if (!mimeType) {\n    throw new Error('A valid MIME type must be specified.');\n  }\n\n  let typeHandler = wtt[LOADERS][mimeType];\n  if (!typeHandler) {\n    typeHandler = wtt[LOADERS]['*'];\n  }\n\n  // Get the appropriate loader for the extension. Will instantiate the loader instance the first time it's\n  // used.\n  const loader = typeHandler.getLoader();\n  if (!loader) {\n    throw new Error(`Failed to get loader for MIME type \"${mimeType}\"`);\n  }\n  return loader;\n}\n\n/**\n * Base texture loader class.\n * Must not be used directly, create an instance of WebGLTextureLoader or WebGPUTextureLoader instead.\n */\nexport class TextureLoaderBase {\n  /**\n   * WebTextureTool constructor. Must not be called by applications directly.\n   * Create an instance of WebGLTextureTool or WebGPUTextureTool as needed instead.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   */\n  constructor(client) {\n    this[CLIENT] = client;\n    this[LOADERS] = {};\n\n    // Map every available extension to it's associated handler\n    for (const extensionHandler of EXTENSION_HANDLERS) {\n      for (const mimeType of extensionHandler.mimeTypes) {\n        this[LOADERS][mimeType] = extensionHandler;\n      }\n    }\n\n    // Register one last \"fallback\" extension. Anything that we receive that has an unrecognized extension will try to\n    // load with the ImageTextureLoader.\n    this[LOADERS]['*'] = EXTENSION_HANDLERS[0];\n  }\n\n  /** Loads a texture from the given URL\n   *\n   * @param {string} url - URL of the file to load.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromUrl(url, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    // Use this to resolve to a full URL.\n    TMP_ANCHOR.href = url;\n\n    // If an explicit extension wasn't provided, examine the URL to determine one.\n    if (!options.mimeType) {\n      // Isolate just the pathname from the given URL, then split the extension off of that.\n      const extIndex = TMP_ANCHOR.pathname.lastIndexOf('.');\n      const extension = extIndex > -1 ? TMP_ANCHOR.pathname.substring(extIndex+1).toLowerCase() : '*';\n      options.mimeType = EXTENSION_MIME_TYPES[extension];\n    }\n\n    const loader = getMimeTypeLoader(this, options.mimeType);\n    return loader.fromUrl(this[CLIENT], TMP_ANCHOR.href, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromBlob(blob, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    const loader = getMimeTypeLoader(this, blob.type);\n    return loader.fromBlob(this[CLIENT], blob, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromBuffer(buffer, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!options.mimeType && options.filename) {\n      const extIndex = options.filename.lastIndexOf('.');\n      const extension = extIndex > -1 ? options.filename.substring(extIndex+1).toLowerCase() : null;\n      options.mimeType = EXTENSION_MIME_TYPES[extension];\n    }\n\n    const loader = getMimeTypeLoader(this, options.mimeType);\n    return loader.fromBuffer(this[CLIENT], buffer, options);\n  }\n\n  /** Loads a texture from the given image element.\n   *\n   * @param {Element} element - HTML element (img, canvas, video, etc) to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromElement(element, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!IMAGE_BITMAP_SUPPORTED) {\n      return this[CLIENT].textureFromImageElement(element, 'rgba8unorm', options);\n    }\n    const imageBitmap = await createImageBitmap(element);\n    return this[CLIENT].fromImageBitmap(imageBitmap, 'rgba8unorm', options);\n  }\n\n  /** Loads a texture from the given image bitmap.\n   *\n   * @param {ImageBitmap} imageBitmap - Image bitmap to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromImageBitmap(imageBitmap, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n    return this[CLIENT].fromImageBitmap(imageBitmap, 'rgba8unorm', options);\n  }\n\n  /**\n   * Creates a 1x1 texture with the specified color.\n   *\n   * @param {number} r - Red channel value\n   * @param {number} g - Green channel value\n   * @param {number} b - Blue channel value\n   * @param {number} [a=1.0] - Alpha channel value\n   * @param {WebTextureFormat} [format='rgba8unorm'] - Format to create the texture with\n   * @returns {WebTextureResult} - Completed WebTextureResult\n   */\n  fromColor(r, g, b, a = 1.0, format = 'rgba8unorm') {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    if (format != 'rgba8unorm' && format != 'rgba8unorm-srgb') {\n      throw new Error('fromColor only supports \"rgba8unorm\" and \"rgba8unorm-srgb\" formats');\n    }\n    const data = new Uint8Array([r * 255, g * 255, b * 255, a * 255]);\n    return this[CLIENT].fromTextureData(new WebTextureData(format, 1, 1, data), false);\n  }\n\n  /**\n   * Creates a noise texture with the specified dimensions. (rgba8unorm format)\n   *\n   * @param {number} width - Width of the noise texture\n   * @param {number} height - Height of the noise texture\n   * @returns {WebTextureResult} - Completed WebTextureResult\n   */\n   fromNoise(width, height) {\n    // TODO: Better noise, more noise varieties, and more texture formats.\n\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    const data = new Uint8Array(width * height * 4);\n    for (let i = 0; i < data.length; ++i) {\n      data[i] = Math.random() * 255;\n    }\n    return this[CLIENT].fromTextureData(new WebTextureData('rgba8unorm', width, height, data), false);\n  }\n\n  /**\n   * Sets whether or not compressed formats should be loaded.\n   * If `false` and a compressed texture can be transcoded to an uncompressed format it will be, otherwise it will be\n   * rejected.\n   *\n   * @param {boolean} value - `true` if compressed formats should be loaded.\n   */\n  set allowCompressedFormats(value) {\n    this[CLIENT].allowCompressedFormats = !!value;\n  }\n\n  /**\n   * Returns whether or not compressed formats should be loaded.\n   *\n   * @returns {boolean} `true` if compressed formats should be loaded.\n   */\n  get allowCompressedFormats() {\n    return this[CLIENT].allowCompressedFormats;\n  }\n\n  /**\n   * Sets whether or not texStorage functions should be used.\n   * Only affects the behavior of WebGL 2.0 loaders\n   *\n   * @param {boolean} value - `true` if texStorage functions should be allowed.\n   */\n   set allowTexStorage(value) {\n    this[CLIENT].allowTexStorage = !!value;\n  }\n\n  /**\n   * Returns whether or not texStorage functions should be used.\n   *\n   * @returns {boolean} `true` if texStorage functions should be allowed.\n   */\n  get allowTexStorage() {\n    return this[CLIENT].allowTexStorage;\n  }\n\n  /**\n   * Destroys the texture tool and stops any in-progress texture loads that have been started.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this[CLIENT]) {\n      this[CLIENT].destroy();\n      this[CLIENT] = null;\n\n      // TODO: Should this happen?\n      // Would have to make sure every instance had it's own copies of the loaders.\n      // Shut down every loader that this class has initialized.\n      /*\n      for (const extensionHandler of this[LOADERS]) { // Doesn't work\n        if (extensionHandler.loader) {\n          extensionHandler.loader.destroy();\n          extensionHandler.loader = null;\n        }\n      }\n      */\n    }\n  }\n}\n", "/**\n * Supports loading textures for both WebGL and WebGL 2.0\n *\n * @file WebGL client for the Web Texture Tool\n * @module WebGLTextureLoader\n */\n\nimport {TextureLoaderBase, WebTextureResult} from './texture-loader-base.js';\nimport {WebTextureFormat} from './texture-format.js';\n\n// For access to WebGL enums without a context.\nconst GL = WebGLRenderingContext;\n\n/**\n * Determines if the given value is a power of two.\n *\n * @param {number} n - Number to evaluate.\n * @returns {boolean} - True if the number is a power of two.\n */\nfunction isPowerOfTwo(n) {\n  return (n & (n - 1)) === 0;\n}\n\n/**\n * Determines the number of mip levels needed for a full mip chain given the width and height of texture level 0.\n *\n * @param {number} width of texture level 0.\n * @param {number} height of texture level 0.\n * @returns {number} - Ideal number of mip levels.\n */\nfunction calculateMipLevels(width, height) {\n  return Math.floor(Math.log2(Math.max(width, height))) + 1;\n}\n\n/**\n * Returns the associated WebGL values for the given mapping, if they exist.\n *\n * @param {module:WebTextureTool.WebTextureFormat} format - Texture format string.\n * @returns {object} - WebGL values that correspond with the given format.\n */\nfunction resolveFormat(format) {\n  const wtFormat = WebTextureFormat[format];\n  if (!wtFormat || !wtFormat.gl) {\n    throw new Error(`No matching WebGL format for \"${format}\"`);\n  }\n\n  return wtFormat;\n}\n\n/**\n * Gets the WebGL texture target required for a given texture type.\n * \n * @param {GPUTextureViewDimension} type - Texture type.\n * @returns {GLenum} - WebGL texture target.\n */\nfunction webTextureTypeToGLTarget(type) {\n  switch (type) {\n    case 'cube':\n      return GL.TEXTURE_CUBE_MAP;\n    case '2d':\n    default:\n      return GL.TEXTURE_2D;\n  }\n}\n\n/**\n * Variant of TextureLoaderBase which produces WebGL textures.\n */\nexport class WebGLTextureLoader extends TextureLoaderBase {\n  /**\n   * Creates a WebGLTextureLoader instance.\n   *\n   * @param {(module:External.WebGLRenderingContext|module:External.WebGL2RenderingContext)} gl - WebGL context to use.\n   * @param {object} toolOptions - Options to initialize this WebTextureTool instance with.\n   */\n  constructor(gl, toolOptions) {\n    super(new WebGLTextureClient(gl), toolOptions);\n  }\n}\n\n/**\n * Variant of TextureLoaderBase that uses WebGL.\n */\nclass WebGLTextureClient {\n  /**\n   * Creates a WebTextureClient instance which uses WebGL.\n   * Should not be called outside of the WebGLTextureTool constructor.\n   *\n   * @param {(module:External.WebGLRenderingContext|module:External.WebGL2RenderingContext)} gl - WebGL context to use.\n   */\n  constructor(gl) {\n    this.gl = gl;\n    this.isWebGL2 = this.gl instanceof WebGL2RenderingContext;\n    this.allowCompressedFormats = true;\n    this.allowTexStorage = true;\n\n    // Compressed Texture Extensions\n    this.extensions = {\n      astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n      bptc: gl.getExtension('EXT_texture_compression_bptc'),\n      etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n      etc2: gl.getExtension('WEBGL_compressed_texture_etc'),\n      pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc'),\n      s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n    };\n\n    this.uncompressedFormatList = [\n      'rgb8unorm', 'rgba8unorm', 'rgb565unorm', 'rgba4unorm',\n    ];\n\n    this.supportedFormatList = [\n      'rgb8unorm', 'rgba8unorm', 'rgb565unorm', 'rgba4unorm',\n    ];\n\n    if (this.isWebGL2) {\n      this.uncompressedFormatList.push('rgb8unorm-srgb', 'rgba8unorm-srgb');\n      this.supportedFormatList.push('rgb8unorm-srgb', 'rgba8unorm-srgb');\n    } else {\n      this.extensions.srgb = gl.getExtension('EXT_sRGB');\n      if (this.extensions.srgb) {\n        this.uncompressedFormatList.push('rgb8unorm-srgb', 'rgba8unorm-srgb');\n        this.supportedFormatList.push('rgb8unorm-srgb', 'rgba8unorm-srgb');\n      }\n    }\n\n    if (this.extensions.astc) {\n      this.supportedFormatList.push('astc-4x4-rgba-unorm');\n    }\n    if (this.extensions.bptc) {\n      this.supportedFormatList.push('bc7-rgba-unorm');\n    }\n    if (this.extensions.etc1) {\n      this.supportedFormatList.push('etc1-rgb-unorm');\n    }\n    if (this.extensions.etc2) {\n      this.supportedFormatList.push('etc2-rgba8unorm');\n    }\n    if (this.extensions.pvrtc) {\n      this.supportedFormatList.push('pvrtc1-4bpp-rgb-unorm', 'pvrtc1-4bpp-rgba-unorm');\n    }\n    if (this.extensions.s3tc) {\n      this.supportedFormatList.push('bc1-rgb-unorm', 'bc2-rgba-unorm', 'bc3-rgba-unorm');\n    }\n  }\n\n  /**\n   * Returns a list of the WebTextureFormats that this client can support.\n   *\n   * @returns {Array<module:WebTextureTool.WebTextureFormat>} - List of supported WebTextureFormats.\n   */\n  supportedFormats() {\n    if (this.allowCompressedFormats) {\n      return this.supportedFormatList;\n    } else {\n      return this.uncompressedFormatList;\n    }\n  }\n\n  /**\n   * Creates a WebGLTexture from the given ImageBitmap.\n   *\n   * @param {module:External.ImageBitmap} imageBitmap - ImageBitmap source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  fromImageBitmap(imageBitmap, format, options) {\n    const gl = this.gl;\n    if (!gl) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    let generateMipmaps = options.mipmaps;\n    // For WebGL 1.0 only generate mipmaps if the texture is a power of two size.\n    if (!this.isWebGL2 && generateMipmaps) {\n      generateMipmaps = isPowerOfTwo(imageBitmap.width) && isPowerOfTwo(imageBitmap.height);\n    }\n    const mipLevels = generateMipmaps ? calculateMipLevels(imageBitmap.width, imageBitmap.height) : 1;\n\n    const wtFormat = resolveFormat(format);\n    if (wtFormat.compressed) {\n      throw new Error(`Cannot create texture from image with compressed format \"${format}\"`);\n    }\n\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    if (this.isWebGL2 && this.allowTexStorage) {\n      gl.texStorage2D(gl.TEXTURE_2D, mipLevels, wtFormat.gl.sizedFormat, imageBitmap.width, imageBitmap.height);\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, wtFormat.gl.format, wtFormat.gl.type, imageBitmap);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, wtFormat.gl.format, wtFormat.gl.format, wtFormat.gl.type, imageBitmap);\n    }\n\n    if (mipLevels > 1) {\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    return new WebTextureResult(texture, {width: imageBitmap.width, height: imageBitmap.height, mipLevels, format});\n  }\n\n  /**\n   * Creates a WebGLTexture from the given HTMLImageElement.\n   *\n   * @param {module:External.HTMLImageElement} image - image source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  fromImageElement(image, format, options) {\n    // The methods called to createa a texture from an image element are exactly the same as the imageBitmap path.\n    return this.textureFromImageBitmap(image, format, options);\n  }\n\n  /**\n   * Creates a WebGLTexture from the given texture data.\n   *\n   * @param {module:WebTextureTool.WebTextureData} textureData - Object containing data and layout for each image and\n   * mip level of the texture.\n   * @param {boolean} generateMipmaps - True if mipmaps generation is desired. Only applies if a single level is given\n   * and the texture format is renderable.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  fromTextureData(textureData, options) {\n    const gl = this.gl;\n    if (!gl) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const wtFormat = resolveFormat(textureData.format);\n    let generateMipmaps = options.mipmaps;\n    // Can't automatically generate mipmaps for compressed formats.\n    if (wtFormat.compressed) {\n      generateMipmaps = false;\n    }\n\n    // For WebGL 1.0 only generate mipmaps if the texture is a power of two size.\n    if (!this.isWebGL2 && generateMipmaps) {\n      generateMipmaps = isPowerOfTwo(textureData.width) && isPowerOfTwo(textureData.height);\n    }\n    const mipLevelCount = textureData.levels.length > 1 ? textureData.levels.length :\n                          (generateMipmaps ? calculateMipLevels(textureData.width, textureData.height) : 1);\n\n    const target = webTextureTypeToGLTarget(textureData.type);\n\n    const texture = gl.createTexture();\n    gl.bindTexture(target, texture);\n\n    const useTexStorage = this.isWebGL2 && (!wtFormat.compressed || wtFormat.gl.texStorage) && this.allowTexStorage;\n    if (useTexStorage) {\n      gl.texStorage2D(target, mipLevelCount, wtFormat.gl.sizedFormat, textureData.width, textureData.height);\n    }\n\n    for (let levelIndex = 0; levelIndex < textureData.levels.length; ++levelIndex) {\n      const level = textureData.levels[levelIndex];\n\n      for (let sliceIndex = 0; sliceIndex < level.slices.length; ++sliceIndex) {\n        const slice = level.slices[sliceIndex];\n        const uploadTarget = target == GL.TEXTURE_CUBE_MAP ? GL.TEXTURE_CUBE_MAP_POSITIVE_X + sliceIndex : target;\n\n        let sliceData;\n        switch (textureData.format) {\n          case 'rgb565unorm':\n          case 'rgba4unorm':\n          case 'rgba5551unorm':\n            sliceData = new Uint16Array(slice.buffer, slice.byteOffset, slice.byteLength / 2);\n            break;\n          default:\n            sliceData = new Uint8Array(slice.buffer, slice.byteOffset, slice.byteLength);\n            break;\n        }\n\n        if (wtFormat.compressed) {\n          if (useTexStorage) {\n            gl.compressedTexSubImage2D(\n                uploadTarget, levelIndex,\n                0, 0, level.width, level.height,\n                wtFormat.gl.sizedFormat,\n                sliceData);\n          } else {\n            gl.compressedTexImage2D(\n                uploadTarget, levelIndex, wtFormat.gl.sizedFormat,\n                level.width, level.height, 0,\n                sliceData);\n          }\n        } else {\n          if (useTexStorage) {\n            gl.texSubImage2D(\n                uploadTarget, levelIndex,\n                0, 0, level.width, level.height,\n                wtFormat.gl.format, wtFormat.gl.type,\n                sliceData);\n          } else {\n            gl.texImage2D(\n                uploadTarget, levelIndex, wtFormat.gl.sizedFormat,\n                level.width, level.height, 0,\n                wtFormat.gl.format, wtFormat.gl.type,\n                sliceData);\n          }\n        }\n      }\n    }\n\n    if (generateMipmaps && textureData.levels.length == 1) {\n      gl.generateMipmap(target);\n    }\n\n    return new WebTextureResult(texture, {\n      width: textureData.width,\n      height: textureData.height,\n      depth: textureData.depth,\n      mipLevels: mipLevelCount,\n      format: textureData.format,\n      type: textureData.type,\n    });\n  }\n\n  /**\n   * Destroy this client.\n   * The client is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.gl = null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
